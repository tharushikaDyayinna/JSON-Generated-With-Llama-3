import streamlit as st
from google import genai
from google.genai import types
import json

# --- 1. SETUP AND CLIENT INITIALIZATION ---
# The name used here must match the key name you save in Streamlit Cloud
try:
    # Access the API key from Streamlit's secrets storage
    GOOGLE_API_KEY = st.secrets["GOOGLE_API_KEY"]
except KeyError:
    st.error("API Key not found! Please set the 'GOOGLE_API_KEY' secret in the Streamlit Cloud settings.")
    st.stop() # Stop the app if the key is missing

# Initialize the client with the secret key
try:
    client = genai.Client(api_key=GOOGLE_API_KEY)
except Exception as e:
    st.error(f"Failed to initialize Google GenAI client: {e}")
    st.stop() # Stop the app if initialization fails

# Using a powerful model suitable for complex JSON generation
GEMINI_MODEL = 'gemini-2.5-flash'


# --- 2. SESSION STATE INITIALIZATION ---
if 'messages' not in st.session_state:
    st.session_state['messages'] = []
if 'generated_json' not in st.session_state:
    # Initialize with a basic, valid structure
    st.session_state['generated_json'] = '{"formData": {"newformName": "Draft Form"}, "fieldsData": [], "operations": []}'
if 'is_initial' not in st.session_state:
    st.session_state['is_initial'] = True


# --- 3. JSON SCHEMA DEFINITION (Used for prompting) ---
# Simplified example now that the tool handles the complex part
JSON_STRUCTURE_EXAMPLE = """{
    "formData": {
        "entityType": "T Department",
        "formCategory": "T Form",
        "formName": "Invoice",
        "frequency": "any",
        "editable": 1,
        "deletable": 1,
        "newRec": 1,
        "parentID": 0
    },
    "fieldsData": [
        {
            "data_name": "Invoice ID",
            "data_type": "sequence",
            "sorting_value": 10,
            "keyMember": 0,
            "prefix": "POL",
            "sufix": "",
            "digits": "1",
            "replacer": "0",
            "start_with": "1",
            "help_text": ""
        },
        // 'options_search' structure is now generated by the Python tool
        {
            "data_name": "Unit Price",
            "data_type": "number",
            "sorting_value": 60,
            "decimals": "2",
            "help_text": ""
        },
        {
            "data_name": "Line Total",
            "data_type": "calculation",
            "sorting_value": 70,
            "calculation": "{GoodsReceived^Quantity^GoodsReceived.GRNLineID,Invoice.Product ID,=} * {Invoice.Unit Price}",
            "decimals": "2",
            "help_text": ""
        }
    ],
    "operations": [
        {
            // ... (Basic operation structure preserved for context) ...
            "mapping": [
                ["Invoice.Invoice ID", "Invoice history.Reference No", "=", ""],
                ["Invoice.Customer Name", "Invoice history.Customer Name", "=", ""]
            ],
            "operationGroups": [
                {
                    "name": "Invoice Update",
                    "list": "1253",
                    "group_type": "0",
                    "mc_field": "0",
                    "menue_condition": "",
                    "mc_value": "",
                    "exclude_menu": "1",
                    "on_submit": "1",
                    "auth_category": "",
                    "menu_sort": "0"
                }
            ]
        }
    ]
}"""


# --- 4. NEW TOOL: STRICT SEARCH SYNTAX GENERATOR ---
# This function is exposed to the model and enforces the complex string structure.
# It returns a fully formed JSON fragment string.
@st.cache_data
def define_options_search_field(
    data_name: str,
    sorting_value: int,
    source_form_name: str,
    display_fields: list[str],
    hidden_field: str,
    mapping_source_field: str,
    mapping_target_field: str,
    filter_field: str,
    filter_value: str
) -> str:
    """
    Creates the required strict search_syntax string and returns a JSON fragment
    for an options_search field. Returns the full field JSON fragment as a string.
    """
    
    # 1. Build the Display Fields list with FormName.FieldName prefix
    # NOTE: Assuming fields in display_fields are just the field name (e.g., 'Vendor Name')
    display_refs = [f"{source_form_name}.{f}" for f in display_fields]
    display_segment = ",".join(display_refs)

    # 2. Hidden Field segment
    hidden_segment = hidden_field 
    
    # 3. Mapping segment
    mapping_segment = f"{mapping_source_field}={mapping_target_field}"
    
    # 4. Filter segment
    filter_segment = f"{filter_field}={filter_value}"
    
    # 5. Assemble the FINAL, STRICTLY REQUIRED search_syntax string
    search_syntax = (
        f"{source_form_name}${display_segment}${hidden_segment}${mapping_segment}${filter_segment}"
    )

    # 6. Return the full field JSON fragment as a string
    field_json = {
        "data_name": data_name,
        "data_type": "options_search",
        "sorting_value": str(sorting_value),
        "formName": source_form_name,
        "search_syntax": search_syntax,
        "help_text": ""
    }
    # Return a stringified JSON object that the main script will insert
    return json.dumps(field_json)


# --- 5. CORE GENERATION / EDITING FUNCTION (Updated for Tool Use) ---
def generate_or_edit_json(prompt):
    """Handles both initial JSON generation and subsequent iterative editing using the Gemini API."""

    is_initial = st.session_state['is_initial']
    
    # --- INSTRUCTION DETAILS FOR OPERATIONS ---
    OPERATION_RULES = """
**NEW KEY: "operations"**: This is a top-level array.
**CRITICAL INSTRUCTION FOR operationGroups**: Each object in 'operationGroups' MUST contain 'exclude_menu' with values "0", "1", "2", "3", or "4".
"""
    # --- INSTRUCTION FOR TOOL USE ---
    TOOL_USE_INSTRUCTION = """
**TOOL INSTRUCTION**: For any request that clearly specifies an 'options_search' field (with details like source form, display fields, mapping, or filters), you **MUST** use the provided `define_options_search_field` tool/function.
Fill the arguments of the tool using the user's request, especially ensuring sorting_value is appropriate (e.g., 20, 30, 40...).
**DO NOT** generate the 'options_search' field structure or the 'search_syntax' string yourself.
"""

    if is_initial:
        # Initial generation prompt
        system_instruction = f"""Generate a complete JSON object.

**MANDATORY**: Response must be ONLY valid JSON or a Function Call.
**CRITICAL**: "fieldsData" and "operations" must match the provided schema structure.
**MANDATORY DATA TYPES**: The 'data_type' key MUST ONLY use: **sequence, options, options_search, date, text, number, calculation**.
**MANDATORY**: 'sorting_value' must be in intervals of 10.
**MANDATORY**: 'help_text' must be "".
**OPTIONS RULE**: For 'options' and 'options_search' types, include "formName".

{OPERATION_RULES}
{TOOL_USE_INSTRUCTION}

JSON Structure Example:
{JSON_STRUCTURE_EXAMPLE}
"""
        user_content = f"Requirement: {prompt}"

    else:
        # Editing prompt
        current_json = st.session_state['generated_json']
        system_instruction = f"""You are a JSON form editing assistant. Modify the CURRENT JSON based on the request.

**CURRENT JSON**: {current_json}

**MANDATORY**: Response must be ONLY valid JSON or a Function Call.
**CRITICAL**: Preserve existing fields unless asked to change.
**SCHEMA REMINDER**: Adhere to the structure in the JSON Structure Example. Use a sorting_value that is appropriate relative to existing fields.

{OPERATION_RULES}
{TOOL_USE_INSTRUCTION}

JSON Structure Example:
{JSON_STRUCTURE_EXAMPLE}
"""
        user_content = f"Please apply this change to the current JSON: {prompt}"

    # Configure request to allow function calling (pass the tool function)
    config = types.GenerateContentConfig(
        tools=[define_options_search_field] 
    )

    try:
        full_prompt = f"System Instruction:\n{system_instruction}\n\nUser Request:\n{user_content}"
        
        completion = client.models.generate_content(
            model=GEMINI_MODEL,
            contents=full_prompt,
            config=config
        )

        # --- HANDLE FUNCTION CALLS ---
        if completion.function_calls:
            function_call = completion.function_calls[0]
            function_name = function_call.name
            function_args = dict(function_call.args)

            if function_name == "define_options_search_field":
                # 1. Execute the Python function to get the perfectly formatted field JSON string
                field_fragment_string = define_options_search_field(**function_args)
                
                # 2. Load and modify the main JSON structure
                current_json_obj = json.loads(st.session_state['generated_json'])
                field_fragment = json.loads(field_fragment_string)

                # Append the new field fragment
                current_json_obj['fieldsData'].append(field_fragment) 

                formatted_json = json.dumps(current_json_obj, indent=4)
                st.session_state['generated_json'] = formatted_json
                st.session_state['is_initial'] = False
                
                return f"✅ **Tool Used**: New `options_search` field generated by the function. The complex `search_syntax` is guaranteed to be in the exact required string format."

            else:
                return f"❌ Model called unknown function: {function_name}"
        
        # --- HANDLE DIRECT JSON GENERATION (for non-search fields) ---
        else:
            generated_text = completion.text
            try:
                parsed_json = json.loads(generated_text)
                formatted_json = json.dumps(parsed_json, indent=4)
                st.session_state['generated_json'] = formatted_json
                st.session_state['is_initial'] = False
                
                return "JSON generated/updated directly (No function call required)."

            except json.JSONDecodeError:
                return f"❌ Error: Model did not return valid JSON. Raw Output: {generated_text[:200]}..."

    except Exception as e:
        return f"❌ API Error: {e}"

# --- 6. STREAMLIT UI LAYOUT (UNMODIFIED) ---
st.set_page_config(page_title="JSON Editor Chat", page_icon="https://www.needlu.com/webImage/needluLogoV.png", layout="wide")
st.title("Needlu Form Generator")
st.markdown("Enter your requirement below.")

# Create two columns for the split view
col1, col2 = st.columns([1, 1])

with col1:
    st.subheader("Chat Interface")

    # Display the chat history
    for message in st.session_state['messages']:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])

    # Handle new user input
    if prompt := st.chat_input("Enter your initial form requirement or a modification"):
        # Add user message to state
        st.session_state['messages'].append({"role": "user", "content": prompt})

        # Get response from the model
        if client:
            with st.spinner(f"Processing..."):
                assistant_response_text = generate_or_edit_json(prompt)
        else:
            assistant_response_text = "❌ Google GenAI client is not initialized. Check API key configuration."

        # Add assistant response (narrative) to state
        st.session_state['messages'].append({"role": "assistant", "content": assistant_response_text})

        # Display assistant message
        with st.chat_message("assistant"):
            st.markdown(assistant_response_text)

        # Rerun to update the JSON display in col2
        st.rerun()


with col2:
    st.subheader("Current Generated JSON")

    # Display the latest generated JSON artifact
    st.code(st.session_state['generated_json'], language="json")

    # Download button for the current artifact
    st.download_button(
        label="Download Current JSON",
        data=st.session_state['generated_json'],
        file_name="generated_form_latest.json",
        mime="application/json"
    )

    if st.session_state['is_initial']:
        st.info("Start by entering your form requirement (e.g., 'Create a Purchase Order form with fields for Vendor, Item, Quantity, and Price').")
    else:
        st.success("Refine the JSON using the chat interface on the left.")
